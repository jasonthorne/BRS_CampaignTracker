Barbarossa:
https://en.wikipedia.org/wiki/Axis_and_Soviet_air_operations_during_Operation_Barbarossa#Siege_of_Leningrad


++++++++++ADD new plane with the relevent dates it's active and the level of asctivity (hashmap with key being date and value being status), DURING first hashmap creation.


ab
ac
ad
ae
af

bc
bd
be
bf

cd
ce
cf

de
df

ef


[A, B], [A, C], [A, D], [A, E], [A, F], [B, C], [B, D], [B, E], [B, F], [C, D], [C, E], [C, F], [D, E], [D, F], [E, F]]
[B, A], [C, A], [D, A], [E, A], [F, A], [C, B], [D, B], [E, B], [F, B], [D, C], [E, C], [F, C], [E, D], [F, D], [F, E]]

//each letter picks a random letter associated with it. 

A(ab,ac,ad,ae,af)
B(ba,bc,bd,ae,af)
C....



A(ab,ac,ad,	ba,ca,da)
B(ba,bc,bd,	ab,cb,db)
C(ca,cb,cd,	ac,bc,dc)
D(da,db,dc,	ad,bd,cd)


A() index[0]: ab - 5 gone
B()
C(cd,	,dc)
D(dc,	cd)


//=================================



randomly pick a key, randomly pick a val from that key.

then remove that key and key of picked value, and each instance of those characters in every other values list.

A=[B, C, D, E, F], B=[A, C, D, E, F], C=[A, B, D, E, F], D=[A, B, C, E, F], E=[A, B, C, D, F], F=[A, B, C, D, E]}


AB CD EF

THEN during repairing, replace the keys of both picked chars, but remove the picked characters from eachother's values list. ie: 

picked AB:
A=[B, C, D, E, F], B=[A, C, D, E, F]

A & B value lists are now:

A=[C, D, E, F], B=[C, D, E, F]







//--------------------------------------------------

1 - create map of players and their potential opponents: 

playerToOpponents {A=[B, C, D, E, F], B=[A, C, D, E, F], C=[A, B, D, E, F], D=[A, B, C, E, F], E=[A, B, C, D, F], F=[A, B, C, D, E]}

==========
2 - create map of players and their previously paired opponents (with initially empty lists):

playerToPrevOpps {A=[], B=[], C=[], D=[], E=[], F=[]}

==========
3 - create a list of players from keys of playerToOpponents for selecting opponents from:

playerOnes = new ArrayList<String>(playerToOpponents.keySet());

==========
4 - randomly select a playerOne from list of playerOnes:

String playerOne = playerOnes.get(new Random().nextInt(playerOnes.size())); 

==========
5 - randomly select a playerTwo from playerOne's opponents list in playerToOpponents:

List<String>playerTwos = playerToOpponents.get(playerOne);
String playerTwo = playerTwos.get(new Random().nextInt(playerTwos.size()));

==========++++++++++
6 - remove playerOne & playerTwo from playerOnes (to prevent re-selection):

playerOnes.removeAll(Arrays.asList(playerOne, playerTwo));

==========
7 - remove playerOne & playerTwo from all playerToOpponents values:

==========
8 - store playerOne & playerTwo as eachother's opponents in playerToPrevOpps:

==========
9 - remove playerOne & playerTwo from all playerToOpponents values (to prevent re-selection):

==========
10 - repeat 4 - 9 untill all round 1 pairings (# of players /2) are made 

==========
11 - repeat 4 - 9 untill all pairings (# of players /2) are made 





A=[B, C, D, E, F], B=[A, C, D, E, F], C=[A, B, D, E, F], D=[A, B, C, E, F], E=[A, B, C, D, F], F=[A, B, C, D, E]}


key checks the number of values left in all of its potential values.
If one is higher than the rest, that one is NOT chosen

foreach playerTNextOpps.values 
	find the biggest, and discard that as the partner, ELSE choose a random one.

